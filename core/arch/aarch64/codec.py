#!/usr/bin/python

# **********************************************************
# Copyright (c) 2016 ARM Limited. All rights reserved.
# **********************************************************

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of ARM Limited nor the names of its contributors may be
#   used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL ARM LIMITED OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.

# This script reads "codec.txt" and generates "codec_gen.h" and "opcode.h".
# Run it manually, in this directory, when "codec.txt" has been changed.

import re

N = 32 # bits in an instruction word

header = '/* This file was generated by codec.py from codec.txt. */\n\n'

def encoding_to_str(enc):
    return '%08x %08x %s %s' % enc

def check(encodings):
    tv = dict()
    for i in range(len(encodings)):
        if (encodings[i][0] & encodings[i][1]):
            print 'Bad encoding:', encoding_to_str(encodings[i])
            raise Exception
        if encodings[i][3] in tv:
            if encodings[i][1] != tv[encodings[i][3]]:
                print 'Inconsistent mask:', encoding_to_str(encodings[i])
                raise Exception
        else:
            tv[encodings[i][3]] = encodings[i][1]
        for j in range(i):
            if ((encodings[j][0] ^ encodings[i][0]) &
                ~encodings[j][1] & ~encodings[i][1] == 0):
                print 'Overlapping encodings:'
                print encoding_to_str(encodings[j])
                print encoding_to_str(encodings[i])
                raise Exception

def generate_decoder(encodings):
    def gen(c, encs, depth):
        indent = "    " * depth
        if len(encs) < 4:
            for (f, v, m, t) in sorted(encs, key = lambda (f, v, m, t): (m, t, f, v)):
                c.append('%sif ((enc & 0x%08x) == 0x%08x)' %
                         (indent, ((1 << N) - 1) & ~v, f))
                c.append('%s    return decode_%s(enc, dc, pc, instr, OP_%s);' %
                         (indent, t, m))
            return
        best_b = -1
        best_x = len(encs)
        for b in range(N):
            x0 = 0
            x1 = 0
            for (f, v, _, _) in encs:
                if (1 << b) & (~f | v):
                    x0 += 1
                if (1 << b) & (f | v):
                    x1 += 1
            x = max(x0, x1)
            if x < best_x:
                best_b = b
                best_x = x
        c.append('%sif ((enc >> %d & 1) == 0) {' % (indent, best_b))
        encs0 = []
        encs1 = []
        for e in encs:
            (f, v, _, _) = e
            if (1 << best_b) & (~f | v):
                encs0.append(e)
            if (1 << best_b) & (f | v):
                encs1.append(e)
        gen(c, encs0, depth + 1)
        c.append('%s} else {' % indent)
        gen(c, encs1, depth + 1)
        c.append('%s}' % indent)

    c = ['static bool',
         'decoder(uint enc, dcontext_t *dc, byte *pc, instr_t *instr)',
         '{']
    gen(c, encodings, 1)
    c.append('    return false;')
    c.append('}')
    return '\n'.join(c) + '\n'

def generate_encoder(encodings):
    case = dict()
    for e in encodings:
        (b, m, mn, f) = e
        if not mn in case:
            case[mn] = []
        case[mn].append(e)
    c = ['static uint',
         'encoder(byte *pc, instr_t *i)',
         '{',
         '    uint enc;',
         '    (void)enc;',
         '    switch (i->opcode) {']
    for mn in sorted(case):
        c.append('    case OP_%s:' % (mn))
        encs = sorted(case[mn], key = lambda (b, m, mn, f): (mn, f, b, m))
        enc1 = encs.pop()
        for e in encs:
            (b, m, mn, f) = e
            c.append('        if ((enc = encode_%s(pc, i, 0x%08x)) != ENCFAIL)' % (f, b))
            c.append('            return enc;')
        (b, m, mn, f) = enc1
        c.append('        return encode_%s(pc, i, 0x%08x);' % (f, b))
    c += ['    }',
          '    return ENCFAIL;',
          '}']
    return '\n'.join(c) + '\n'

def generate_opcodes(encodings):
    mns = dict()
    for e in encodings:
        mns[e[2]] = 1
    c = ['#ifndef OPCODE_H',
         '#define OPCODE_H 1',
         '',
         '/* DR_API EXPORT TOFILE dr_ir_opcodes_aarch64.h */',
         '/* DR_API EXPORT BEGIN */',
         '',
         '/****************************************************************************',
         ' * OPCODES',
         ' */',
         '/**',
         ' * @file dr_ir_opcodes_aarch64.h',
         ' * @brief Instruction opcode constants for AArch64.',
         ' */',
         '/** Opcode constants for use in the instr_t data structure. */',
         'enum {',
         '/*   0 */     OP_INVALID,  /* NULL, */ /**< INVALID opcode */',
         '/*   1 */     OP_UNDECODED,  /* NULL, */ /**< UNDECODED opcode */',
         '/*   2 */     OP_CONTD,    /* NULL, */ /**< CONTD opcode */',
         '/*   3 */     OP_LABEL,    /* NULL, */ /**< LABEL opcode */',
         '']
    i = 4
    for mn in sorted(mns):
        t = '/*%4d */     OP_%s,' % (i, mn)
        t += ' ' * max(0, 34 - len(t))
        c.append(t + '/**< AArch64 %s opcode.*/' % mn)
        i += 1
    c += ['',
          '    OP_xx, /* placeholder for undecoded instructions */',
          '',
          '    OP_AFTER_LAST,',
          '    OP_FIRST = OP_LABEL + 1,      /**< First real opcode. */',
          '    OP_LAST  = OP_AFTER_LAST - 1, /**< Last real opcode. */',
          '};',
          '',
          '/* alternative names */',
          '#define OP_jmp       OP_b      '
          '/**< Platform-independent opcode name for jump. */',
          '#define OP_jmp_short OP_b      '
          '/**< Platform-independent opcode name for short jump. */',
          '#define OP_load      OP_ldr    '
          '/**< Platform-independent opcode name for load. */',
          '#define OP_store     OP_str    '
          '/**< Platform-independent opcode name for store. */',
          '',
          '/******************************'
          '**********************************************/',
          '/* DR_API EXPORT END */',
          '',
          '#endif /* OPCODE_H */']
    return '\n'.join(c) + '\n'

def generate_opcode_names(encodings):
    mns = dict()
    for e in encodings:
        mns[e[2]] = 1
    c = ['#ifndef OPCODE_NAMES_H',
         '#define OPCODE_NAMES_H 1',
         '',
         'const char *opcode_names[] = {',
         '/*   0 */ "<invalid>",',
         '/*   1 */ "<undecoded>",',
         '/*   2 */ "<contd>",',
         '/*   3 */ "<label>",']
    i = 4
    for mn in sorted(mns):
        c.append('/*%4d */ "%s",' % (i, mn))
        i += 1
    c += ['          "xx",',
          '};',
          '',
          '#endif /* OPCODE_NAMES_H */']
    return '\n'.join(c) + '\n'

def write_if_changed(file, data):
    try:
        if open(file, 'r').read() == data:
            return
    except IOError:
        pass
    open(file, 'w').write(data)

def main():
    f = open('codec.txt', 'r')
    encodings = []
    for line in f:
        line = re.sub("\s*(#.*)?\n?$", "", line)
        if line == '':
            continue
        x = line.split()
        if (len(x) != 4):
            print 'Wrong number of words:', x
            raise Exception
        if (not re.match("[0-9a-f]{8}$", x[0]) or
            not re.match("[0-9a-f]{8}$", x[1])):
            print 'Bad hex:', x[0], x[1]
            raise Exception
        encodings.append((int(x[0], 16), int(x[1], 16), x[2], x[3]))
    check(encodings)
    write_if_changed('codec_gen.h',
                     header + generate_decoder(encodings) +
                     '\n' + generate_encoder(encodings))
    write_if_changed('opcode.h',
                     header + generate_opcodes(encodings))
    write_if_changed('opcode_names.h',
                     header + generate_opcode_names(encodings))

if __name__ == "__main__":
    main()
