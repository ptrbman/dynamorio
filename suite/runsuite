#!/bin/bash

# **********************************************************
# Copyright (c) 2002-2008 VMware, Inc.  All rights reserved.
# **********************************************************

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# 
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# 
# * Neither the name of VMware, Inc. nor the names of its contributors may be
#   used to endorse or promote products derived from this software without
#   specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL VMWARE, INC. OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.

###########################################################################
##
## BENCHMARK SUITE LAUNCHER FOR SPEC2000
##
## Purpose: to keep all of the data from our runs in one place.
## All data is kept under /home/rio/suite/<key>/<machine>/<dataset-date.run>
## Cagfarm machines are divided into cagfarm-{low,med,high} based on:
##   cagfarm 1-10:  846 MHz Pentium 3
##   cagfarm 11-26: 993 MHz Pentium 3
##   cagfarm 27-49: 2.2 GHz Pentium 4
## After a run all of the generated dynamorio log files are tarred up and stored
## in the data directory so that the benchmarks directory can be cleaned
## and spec data file space reclaimed without losing dynamo log files.
## Also, unless the remotedynamo flag is used, the dynamo source and binary files
## are copied from $DYNAMORIO_HOME into the data directory so we can recreate
## runs in the future.
##
## You must give the base of your benchmarks directory as the first argument.
## Then you tell it test or ref.
## Then you give it a "key", which will be used for the script files as
## well as the run directory names.  If you use a preset key "native", "base",
## or "sidebase", your initial options will be set for you.  You can list
## additional options as arguments after the key.
## Right now there is no explicit support for optimization, but you can list
## the OPTIMIZE=no option.  You can also override the default COPYDATA=yes
## option by adding COPYDATA=no to the end of the options.
##
## There will be forthcoming support on automatically generating
## data on slowdown vs. established native run times.
##
## examples of usage (note how quotes must be escaped):
##   runsuite /home/bits6/iye ref native
##   runsuite /home/bits6/iye test base
##   runsuite /home/bits6/iye test myop DYNAMORIO_OPTIONS=\"-loglevel 1 -superop\" COPYDATA=no
## using the intel compiler:
##   runsuite /scratch/iye rebuild test native CCOMP=\"icc -O3\" FCOMP=\"ifc -O3\"

###########################################################################
# arguments

usage="<bmarkdir> <dataset> [remotedynamo] [rebuild] [cleanall] [noclean] native|release|base|sidebase|<key> [<runops>]"

# mandatory 1st 2 arguments
if [ $# -lt 2 ]; then
    echo "Usage: $0 $usage"
    exit 127
fi
bmarkbase=$1
if ! test -e "$bmarkbase/benchmarks" ; then
    echo "Error: cannot find directory $bmarkbase/benchmarks"
    echo "Usage: $0 $usage"
    exit 127
fi
shift
dataset=$1
shift

# rest of arguments
key=""
noclean=0
rebuild=0
cleanall=0
remotedynamo=0
while [ $# -ge 1 ]; do
    case $1 in
    # separate options
    help)     echo "Usage: $0 $usage"; exit 127 ;;
    rebuild)  rebuild=1 ;;
    noclean)  noclean=1 ;;
    cleanall) cleanall=1 ;;
    remotedynamo) remotedynamo=1 ;;
    # pre-set keys
    native)   key="native"; shift; break ;;
    release)  key="release"; shift; break ;;
    base)     key="base"; shift; break ;;
    sidebase) key="sidebase"; shift; break ;;
    *)        key=$1; shift; break ;;
    esac
    shift
done

# all remaining arguments are part of options
# quoted arguments must have their quotes escaped (\") to remain
# quoted when passed through to RunSuite
ops=""
while [ $# -ge 1 ]; do
    ops="$ops $1"
    shift
done

# check some requirements
if [ -z $key ] ; then
    echo "Usage: $0 $usage"
    exit 127
fi

# get location of runsuite
# FIXME: find way to avoid hardcoding script name here
scriptdir=${0/runsuite/}
if [ -z $scriptdir ] || [ ${scriptdir:0:1} != "/" ]; then
    scriptdir=`pwd`"/$scriptdir";
fi

function rmrfcmd {
    if [ `uname -s` == "Linux" ]; then
        rm -rf $*;
    else
        # get around rm -r bug where it hangs on open files
        # we could use "cmd /c rmdir /s/q" but then we'd have to change
        # paths to win32 so we invoke perl rmtree instead
        perl -e 'use File::Path; rmtree([glob("$*")], 1, 0);';
    fi
}

# can't use rmrf function w/ find's -exec so we have to duplicate here
# also can't have var point to perl string as have problems w/ eval of var
function findrmrfcmd {
    if [ `uname -s` == "Linux" ]; then
        find $* -exec rm -rf {} \;
    else
        # get around rm -r bug where it hangs on open files
        # we could use "cmd /c rmdir /s/q" but then we'd have to change
        # paths to win32 so we invoke perl rmtree instead
        find $* -exec perl -e 'use File::Path; rmtree([glob("{}")], 1, 0);' \;
    fi
}

###########################################################################
# build directory for this run

# make dir for this run: key/host/date.run
if ! test -e $key ; then 
    mkdir $key
fi
cd $key
hostnm=`hostname`
host=$hostnm
if [ ${host:0:8} == "cagfarm-" ]; then
    # split cagfarms up into three groups, low, med, and high:
    #   cagfarm 1-10:  846 MHz Pentium 3
    #   cagfarm 11-26: 993 MHz Pentium 3
    #   cagfarm 27-49: 2.2 GHz Pentium 4
    if [ ${host:8:1} == "0" ] || [ $host == "cagfarm-10" ]; then
        host="cagfarm-low"
    elif [ ${host:8:1} == "3" ] || [ ${host:8:1} == "4" ] ||
         [ $host == "cagfarm-27" ] || [ $host == "cagfarm-28" ] ||
         [ $host == "cagfarm-29" ]; then
        host="cagfarm-high"
    else
        host="cagfarm-med"
    fi
fi
if ! test -e $host ; then 
    mkdir $host
fi
cd $host
dstamp=`date | awk '{print $6 "-" $2$3}'`.
nstamp=1
stamp=$dataset"-"$dstamp"00"$nstamp
while test -e $stamp ; do
    nstamp=$((++nstamp))
    if [ $nstamp -lt 10 ]; then
        stamp=$dataset"-"$dstamp"00"$nstamp
    elif [ $nstamp -lt 100 ]; then
        stamp=$dataset"-"$dstamp"0"$nstamp
    else
        stamp=$dataset"-"$dstamp$nstamp
    fi
done
mkdir $stamp
cd $stamp

# print useful info
echo "Running $key suite on $hostnm == $host" | tee -a suitelog.$key
rundir=`pwd`;
echo "Running in $rundir" | tee -a suitelog.$key
echo "Script dir is $scriptdir" | tee -a suitelog.$key

if [ $remotedynamo == 0 ] && [ $key != "native" ]; then
    echo "Copying dynamo sources and binaries from $DYNAMORIO_HOME" | tee -a suitelog.$key
    if test -e $DYNAMORIO_HOME; then
        cp -r $DYNAMORIO_HOME/core .
        cp -r $DYNAMORIO_HOME/exports .
    else
        echo "*** Error: DR home $DYNAMORIO_HOME does not exist"
        exit 127
    fi
    if ! test -e $DYNAMORIO_TOOLS; then
        echo "*** Error: DR tools dir $DYNAMORIO_TOOLS does not exist"
        exit 127
    fi
    export DYNAMORIO_HOME=$rundir
fi
if [ $key != "native" ]; then
    echo "DYNAMORIO_HOME is $DYNAMORIO_HOME" | tee -a suitelog.$key
fi
echo "DYNAMORIO_TOOLS is $DYNAMORIO_TOOLS" | tee -a suitelog.$key

###########################################################################
# preparation

if [ $rebuild == 1 ]; then
    echo | tee -a suitelog.$key
    echo "clearing for rebuild" | tee -a suitelog.$key
    date
    sed "s/BMARKBASE/${bmarkbase//\//\\/}/" < $scriptdir/suite-all > clear-sed1
    sed 's/REPLACEHERE/clear/' < clear-sed1 > clear
    $bmarkbase/benchmarks/RunSuite clear > log-clear
    date
    echo "done with clearing for rebuild" | tee -a suitelog.$key
fi

if [ $cleanall == 1 ]; then
    echo | tee -a suitelog.$key
    echo "cleaning up old run dirs" | tee -a suitelog.$key
    date
    pushd $bmarkbase/benchmarks/spec2000/ > /dev/null

    find . -name \*pt-ref\* -type d -exec chmod -R +w {} \;
    find . -name \*pt-train\* -type d -exec chmod -R +w {} \;
    findrmrfcmd . -name \*pt-test\* -type d
    popd > /dev/null
    echo "done with cleaning up old run dirs" | tee -a suitelog.$key
fi

if [ $noclean == 0 ]; then
    echo | tee -a suitelog.$key
    echo "cleaning up previous $key run dirs" | tee -a suitelog.$key
    date
    pushd $bmarkbase/benchmarks/spec2000/ > /dev/null

    find . -name $key-$hostnm-\* -type d -print
    find . -name $key-$hostnm-\* -type d -exec chmod -R +w {} \; > /dev/null 2>&1
    findrmrfcmd . -name $key-$hostnm-\* -type d > /dev/null 2>&1
    popd > /dev/null
    date
    echo "done with cleaning up previous $key run dirs" | tee -a suitelog.$key
else
    echo "not cleaning previous $key run dirs, times may show old runs" | tee -a suitelog.$key
fi

###########################################################################
# run the suite

# must escape all forward slashes, for sed
sedops=${ops//\//\\\/}
if [ $key == "native" ]; then
    replaceme="NATIVE=yes $sedops"
elif [ $key == "release" ]; then
    replaceme="DYNAMORIO_OPTIONS=\"\" $sedops"
elif [ $key == "base" ]; then
    replaceme="DYNAMORIO_OPTIONS=\"-loglevel 1\" $sedops"
elif [ $key == "sidebase" ]; then
    replaceme="DYNAMORIO_OPTIONS=\"-loglevel 1 -sideline\" $sedops"
else
    replaceme=$sedops
fi

template="suite-$dataset"
if ! test -e "$scriptdir$template" ; then
    echo "Error: cannot find template file $scriptdir$template"
    exit 127
fi
sed "s/BMARKBASE/${bmarkbase//\//\\/}/" < $scriptdir$template > $key-sed1
sed "s/REPLACEHERE/RUNDIR=$key-$hostnm $replaceme/" < $key-sed1 > $key
rm $key-sed1

echo | tee -a suitelog.$key
echo "$key" | tee -a suitelog.$key
date | tee -a suitelog.$key
$bmarkbase/benchmarks/RunSuite $key | tee -a suitelog.$key
# make better names
mv $key.log log.$key
mv $key cmds.$key
grep -E 'make:|Verify|Elapsed:|^real|Error:|%%%% /|elapsed|RSS' log.$key > results.$key
date | tee -a suitelog.$key
echo "done with $key" | tee -a suitelog.$key

###########################################################################
# gather data

# N.B.: I used to use `dirs | awk '{print $2}'` to get the run dir after a pushd,
# but something changed b/c now there's a ~ in there and it's not being evaluated,
# so I just use the stored $rundir

# get $key times
if [ $key == "native" ]; then
    pushd $bmarkbase/benchmarks/spec2000/ > /dev/null
    $DYNAMORIO_TOOLS/Summary -times -find "find . -name $key-$hostnm-\* | grep -v '\.[0-9]'" > $rundir/stimes.$key
    popd > /dev/null
else
    pushd $bmarkbase/benchmarks/spec2000/ > /dev/null
    $DYNAMORIO_TOOLS/Summary -times -find "find . -name $key-$hostnm-\* | grep -v '\.[0-9]'" > $rundir/stimes.$key
    # gather up dynamorio files
    logfiles=`find . -name \*.exe.\* -type f | grep "$key-$hostnm-[^0-9]*/" | wc  | awk '{print $1}'`
    if [ $logfiles == 0 ]; then
        popd > /dev/null
        echo "****** Warning: no *log.* files found from run!" | tee -a suitelog.$key
    else
        $DYNAMORIO_TOOLS/Summary -find "find . -type f -name mainlog.\* | grep '$key-$hostnm-[^0-9]*/'" > $rundir/summary.$key
        # support both old and new logdir names
        find . -name dynamorio.\* -o -name \*.\[0-9\]\*.0000000\[0-9\] -type d | grep "$key-$hostnm-[^0-9]*/" | xargs tar cjf $key-logs.tar.bz2
         if [ -e $key-logs.tar.bz2 ]; then
             mv $key-logs.tar.bz2 $rundir
         fi
        popd > /dev/null
    fi
fi

# use bmtable.pl for a nice summary, including memory info
$DYNAMORIO_TOOLS/bmtable.pl log.$key > t-$key
$DYNAMORIO_TOOLS/bmtable.pl -k log.$key > tk-$key
$DYNAMORIO_TOOLS/bmtable.pl -v log.$key > tv-$key

echo "Verification results:"
failures=`find . -name results.\* | xargs grep -E 'FAIL|make:' | wc | awk '{print $1}'`
if [ $failures == 0 ]; then
    echo "No failures -- all benchmarks succeeded" | tee -a suitelog.$key
else
    echo "****** Number of benchmarks that failed: $failures ******" | tee -a suitelog.$key
fi

echo "Post-verification results:"
# bmtable.pl considers [Ee]rror: a failure, we report it separately here
errors=`find . -name results.\* | xargs grep -E '[Ee]rror:' | wc | awk '{print $1}'`
if [ $errors == 0 ]; then
    echo "No post-verify failures" | tee -a suitelog.$key
else
    echo "****** Number of post-verify failures: $errors ******" | tee -a suitelog.$key
    echo "Error messages:"
    find . -name results.\* | xargs grep -E '[Ee]rror:'
    echo ""
fi

if [ $key != "native" ]; then
    # save space (shrinks size by over 75%)
    echo "Tarring up core and exports dirs to save space" | tee -a suitelog.$key
    tar cjf core.tar.bz2 core
    rmrfcmd core
    tar cjf exports.tar.bz2 exports
    rmrfcmd exports
    # auto-compute slowdown vs. native
    lines=`wc t-$key | awk '{print $1}'`
    native_times=../../native/$host/t-native
    if [ $lines == 22 ] && [ test -e "$native_times" ]; then
        # full run of non-native: calculate slowdown vs. native
        echo "calculating slowdown of $key vs. $native_times" | tee -a suitelog.$key
        cd ..
        $DYNAMORIO_TOOLS/bmcmp.pl $stamp/t-$key $native_times > vs-$key-native
    fi
    # FIXME: run graph.pl to build slowdown graph...but the proper perl packages
    # aren't installed on cagfarm machines!
fi

# finish with useful info
echo "Done running $key suite on $host" | tee -a suitelog.$key
echo "Results are in $key/$host/$stamp" | tee -a suitelog.$key
echo ""
cat tv-$key
echo ""
